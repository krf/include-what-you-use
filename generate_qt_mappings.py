#!/usr/bin/env python

##===--- generate_qt_mappings.py ------------------------------------------===##
#
#                     The LLVM Compiler Infrastructure
#
# This file is distributed under the University of Illinois Open Source
# License. See LICENSE.TXT for details.
#
##===----------------------------------------------------------------------===##

"""
This script generates the Qt mapping file according to given Qt include
directory

Example usage :

   $ ./generate_qt_mappings.py /usr/include/x86_64-linux-gnu/qt5 qt5_11.imp

"""

from __future__ import print_function
import argparse
import glob
import os
import re
import sys

IGNORED_HEADERS = [
    "qglobal.h",  # central headers sometimes included by other forwarding headers, ignore
]
EXTRA_SYMBOL_MAPPINGS = {
    #"Q_OBJECT" : "QObject" # otherwise we get qobjectdefs.h (not intended)
}
OVERRIDDEN_SYMBOL_MAPPINGS = {
    "QStaticStringData" : "QString", # defined in qstring.h
    "QStringBuilder" : "QString",
    "QStringLiteral" : "QString"
}
OVERRIDDEN_HEADER_MAPPINGS = {
    "qobjectdefs.h" : "QObject", # qobjectdefs.h is an internal include
    "qstringbuilder.h" : "QString",
    "qstringliteral.h" : "QString"
}

def get_overridden_header_for_symbol(symbol):
    if symbol in OVERRIDDEN_SYMBOL_MAPPINGS:
        return OVERRIDDEN_SYMBOL_MAPPINGS[symbol]

    return symbol

def main(qt_include_dir, output_file):
    symbols_map = []
    includes_map = []

    headers = glob.glob(os.path.join(args.qt_include_dir, '**/*[!.h]'))
    for header in headers:
        if os.path.isdir(header):
            continue

        header_name = os.path.basename(header)
        if header_name in IGNORED_HEADERS:
            continue

        module_name = os.path.basename(os.path.dirname(header))

        # skip module includes (e.g. "QtCore"), they pull in lots of headers
        if header_name == module_name:
            continue

        symbols_map += ['{ symbol: [ "%s", "private", ' % header_name
                        + '"<%s>", "public" ] }' % (OVERRIDDEN_SYMBOL_MAPPINGS[header_name] if header_name in OVERRIDDEN_SYMBOL_MAPPINGS else header_name)]

        with open(header, 'r') as f:
            content = f.read()

        includes = re.findall(r'#include "(.*\.h)"', content)
        for include in includes:
            if include in IGNORED_HEADERS:
                continue

            includes_map += [
                '{ include: [ "@[\\"<](%s/)?%s[\\">]", ' % (
                    module_name, include)
                + '"private", "<%s>", "public" ] }' % (OVERRIDDEN_HEADER_MAPPINGS[include] if include in OVERRIDDEN_HEADER_MAPPINGS else header_name)
            ]

    with open(args.output_file, 'w') as f:
        print("# Do not edit! This file was generated by the script %s." %
              os.path.basename(__file__), file=f)
        print("[", file=f)
        print("  %s" % ",\n  ".join(symbols_map + includes_map), file=f)
        print("]", file=f)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("qt_include_dir", help="Qt include directoy")
    parser.add_argument("output_file", help="Generated output mapping file")
    args = parser.parse_args()
    sys.exit(main(args.qt_include_dir, args.output_file))
